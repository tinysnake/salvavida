using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Linq;
using System.Collections.Immutable;

namespace Salvavida.Generator
{
    public class BasicCodeGenerator : ICodeGenerator
    {
        internal readonly string[] AlternateNameTemplates = new[] { "Sv{0}", "{0}Ob" };
        protected CodeGenInfoStore? _infoStore;

        public virtual bool CanGenerate(CodeGenerationContext ctx) => true;

        public string Generate(CodeGenerationContext ctx)
        {
            _infoStore = new CodeGenInfoStore();
            _infoStore.isOrderedClass = CodeGenHelper.IsOrderedClass(ctx);
            try
            {
                var sb = new ScriptBuilder();
                sb.WriteLine("// <auto-generated/>");
                sb.WriteLine("// This code is Generated by Salvavida Library.");
                sb.WriteLine("#nullable disable");
                sb.WriteLine("#pragma warning disable");
                sb.WriteLine("using Salvavida;");
                sb.WriteLine("using System.Collections.Generic;");
                WriteUsings(sb, ctx);
                sb.WriteLine();
                BeforeWriteNamespace(sb, ctx);
                WriteNamespace(sb, ctx, out var nsIndent);
                BeforeWriteClass(sb, ctx);
                WriteClass(sb, ctx);
                WriteClassBody(sb, ctx);
                sb.EndCurlyBrackets();
                if (nsIndent) sb.EndCurlyBrackets();
                return sb.ToString();
            }
            finally
            {
                _infoStore = null;
            }
        }

        private void WriteNamespace(ScriptBuilder sb, CodeGenerationContext ctx, out bool hasCurlyBrackets)
        {
            hasCurlyBrackets = false;
            var ns = ctx.TypeSymbol.ContainingNamespace;
            if (ns == null || ns.IsGlobalNamespace)
                return;

            if (ctx.LanguageVersion >= LanguageVersion.CSharp10)
            {
                sb.WriteLine($"namespace {ns.ToDisplayString()};");
                sb.WriteLine();
            }
            else
            {
                sb.WriteLine($"namespace {ns.ToDisplayString()}");
                sb.BeginCurlyBrackets(true);
                hasCurlyBrackets = true;
            }
        }

        private void WriteClass(ScriptBuilder sb, CodeGenerationContext ctx)
        {
            var className = ctx.TypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            _infoStore!.className = className;
            sb.Write($"partial class {className} : ISavable<{className}>");
            if (_infoStore!.isOrderedClass)
                sb.Write($", ISaveWithOrder", true);
            sb.WriteLine();
            sb.BeginCurlyBrackets();
        }

        protected virtual void WriteUsings(ScriptBuilder sb, CodeGenerationContext ctx) { }

        protected virtual void BeforeWriteNamespace(ScriptBuilder sb, CodeGenerationContext ctx) { }

        protected virtual void BeforeWriteClass(ScriptBuilder sb, CodeGenerationContext ctx) { }

        protected virtual void WriteClassBody(ScriptBuilder sb, CodeGenerationContext ctx)
        {
            WriteImplementationsHead(sb, ctx);
            var members = ctx.ClassNode.Members;

            foreach (var member in members)
            {
                if (member is FieldDeclarationSyntax fieldSyntax)
                {
                    foreach (var name in fieldSyntax.Declaration.Variables.Select(v => v.Identifier.ToString()))
                    {
                        _infoStore!.existingPropertyNames.Add(name);
                    }
                }
                else if (member is PropertyDeclarationSyntax propSyntax)
                {
                    _infoStore!.existingPropertyNames.Add(propSyntax.Identifier.ToString());
                }
                else if (member is MethodDeclarationSyntax methodSyntax)
                {
                    _infoStore!.existingPropertyNames.Add(methodSyntax.Identifier.ToString());
                }
                else if (member is DelegateDeclarationSyntax delegateSyntax)
                {
                    _infoStore!.existingPropertyNames.Add(delegateSyntax.Identifier.ToString());
                }
                else if (member is TypeDeclarationSyntax typeDeclaration)
                {
                    _infoStore!.existingPropertyNames.Add(typeDeclaration.Identifier.ToString());
                }
                else if (member is EnumDeclarationSyntax enumDeclaration)
                {
                    _infoStore!.existingPropertyNames.Add(enumDeclaration.Identifier.ToString());
                }
                else if (member is NamespaceDeclarationSyntax nsDeclaration)
                {
                    _infoStore!.existingPropertyNames.Add(nsDeclaration.Name.ToString());
                }
            }


            foreach (var member in members)
            {
                if (member is not FieldDeclarationSyntax fieldSyntax)
                    continue;
                HandleField(sb, fieldSyntax, ctx);
            }

            foreach (var member in members)
            {
                if (member is not PropertyDeclarationSyntax propSyntax)
                    continue;
                HandleProperty(sb, propSyntax, ctx);
            }

            foreach (var member in members)
            {
                if (member is not MethodDeclarationSyntax methodSyntax)
                    continue;
                HandleMethod(sb, methodSyntax, ctx);
            }

            WriteImplementationsFoot(sb, ctx);
        }

        protected virtual void HandleField(ScriptBuilder sb, FieldDeclarationSyntax field, CodeGenerationContext ctx)
        {
            var type = field.Declaration.Type;
            var fieldNames = field.Declaration.Variables.Select(f => f.Identifier).ToImmutableArray();
            HandleFieldOrProp(sb, field, type, fieldNames, ctx);
        }

        protected virtual void HandleProperty(ScriptBuilder sb, PropertyDeclarationSyntax prop, CodeGenerationContext ctx)
        {
            var accessors = prop.AccessorList?.Accessors;
            if (accessors == null)
                return;
            bool emptyBody = true;
            bool hasGetter = false;
            bool hasSetter = false;
            foreach (var accessor in accessors!)
            {
                if (!hasGetter)
                    hasGetter |= accessor.IsKind(SyntaxKind.GetAccessorDeclaration);
                if (!hasSetter)
                    hasSetter |= accessor.IsKind(SyntaxKind.SetAccessorDeclaration);
                emptyBody &= accessor.Body == null;
            }
            if (!emptyBody)
                return;
            if (!hasGetter || !hasSetter)
                return;
            var arr = ImmutableArray.Create(prop.Identifier);
            HandleFieldOrProp(sb, prop, prop.Type, arr, ctx);
        }

        protected void HandleFieldOrProp(ScriptBuilder sb, MemberDeclarationSyntax member, TypeSyntax type, ImmutableArray<SyntaxToken> names, CodeGenerationContext ctx)
        {
            foreach (var modifier in member.Modifiers)
            {
                if (modifier.IsKind(SyntaxKind.ReadOnlyKeyword))
                    return;
                if (modifier.IsKind(SyntaxKind.StaticKeyword))
                    return;
            }

            AttributeSyntax? propNameAttr = null;
            AttributeSyntax? ignoreAttr = null;
            AttributeSyntax? saveSeparatelyAttr = null;

            foreach (var attrList in member.AttributeLists)
            {
                foreach (var attr in attrList.Attributes)
                {
                    if (ctx.SemanticModel.GetSymbolInfo(attr).Symbol is not IMethodSymbol attrSymbol)
                        continue;
                    var attrName = attrSymbol.ContainingType.ToDisplayString();
                    if (attrName == CodeGenHelper.PROPERTY_NAME_ATTRIBUTE_NAME)
                        propNameAttr = attr;
                    else if (attrName == CodeGenHelper.IGNORE_ATTRIBUTE_NAME)
                        ignoreAttr = attr;
                    else if (attrName == CodeGenHelper.SAVE_SEPARATELY_ATTRIBUTE_NAME)
                        saveSeparatelyAttr = attr;

                }
            }

            if (ignoreAttr != null)
                return;

            if (names.Length > 1 && propNameAttr != null)
            {
                ctx.SourceProductionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.PropertyNameAttributeNotSupported, propNameAttr.GetLocation()));
                return;
            }

            string? attrPropName = null;
            if (propNameAttr != null)
            {
                var argSyntax = propNameAttr.ArgumentList!.Arguments.ElementAt(0);
                if (argSyntax.Expression is not LiteralExpressionSyntax literalSyntax || !literalSyntax.IsKind(SyntaxKind.StringLiteralExpression))
                {
                    ctx.SourceProductionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.CantResolvePropetyName, propNameAttr.GetLocation()));
                    return;
                }
                else
                    attrPropName = literalSyntax.Token.ValueText;
            }

            foreach (var fieldNameSyntax in names)
            {
                var fieldName = fieldNameSyntax.ValueText;
                if (string.IsNullOrEmpty(fieldName))
                    continue;
                string propertyName;
                if (string.IsNullOrEmpty(attrPropName))
                {
                    var tempName = CodeGenHelper.GetPropertyName(fieldName.AsSpan());
                    if (string.IsNullOrEmpty(tempName))
                    {
                        ctx.SourceProductionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.InvalidMemberName,
                            fieldNameSyntax.GetLocation(), fieldName));
                        return;
                    }
                    else
                        propertyName = tempName!;
                }
                else
                {
                    propertyName = attrPropName!;
                }

                var templateIndex = 0;
                while (_infoStore!.existingPropertyNames.Contains(propertyName))
                {
                    if (templateIndex >= AlternateNameTemplates.Length)
                    {
                        ctx.SourceProductionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.AllCandidateNamesAreUnavailable,
                            fieldNameSyntax.GetLocation(), fieldName));
                        return;
                    }
                    propertyName = string.Format(AlternateNameTemplates[templateIndex++], propertyName);
                }

                _infoStore!.existingPropertyNames.Add(propertyName);


                if (ctx.SemanticModel.GetSymbolInfo(type).Symbol is not ITypeSymbol typeSymbol)
                    return;

                var collectionType = CodeGenHelper.GetCollectionType(ctx, type, ref typeSymbol, out var elemTypeSymbols);
                var saveSeparately = saveSeparatelyAttr != null;
                if (collectionType == CollectionType.None)
                {
                    _infoStore!.nameMappings.Add((fieldName, propertyName));
                    _infoStore.propTypeMappings[fieldName] = typeSymbol;
                    if (saveSeparately)
                        _infoStore!.separatedProperties.Add(propertyName);
                    WriteProperty(sb, ctx, propertyName, fieldName, typeSymbol, saveSeparately);
                }
                else
                {
                    _infoStore!.nameMappings.Add((fieldName, propertyName));
                    _infoStore!.collectionParameterMappings[fieldName] = (collectionType, elemTypeSymbols!);
                    if (saveSeparately)
                    {
                        //var savableElement = CodeGenHelper.TryGetAttribute(ctx, , SalvavidaGenerator.SALVAVIDA_ATTRIBUTE)
                        // TODO: to check if elemTypeSymbols.Last() implemented ISavable or not
                        _infoStore!.separatedCollections.Add(propertyName, false);
                    }
                    var collectionTypeString = GetCollectionTypeString(collectionType, elemTypeSymbols!);
                    WriteCollectionProperty(sb, ctx, propertyName, fieldName,
                        typeSymbol, collectionTypeString, saveSeparately);
                }
            }
        }

        protected virtual void HandleMethod(ScriptBuilder sb, MethodDeclarationSyntax method, CodeGenerationContext ctx)
        {

        }

        protected virtual void WriteProperty(ScriptBuilder sb, CodeGenerationContext ctx, string propertyName, string fieldName, ITypeSymbol typeSymbol, bool saveSeparately)
        {
            var typeFullName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            AddAttributePreventSerialize(sb, false);
            sb.WriteLine($"public {typeFullName} {propertyName}");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine($"get => {fieldName};");
                sb.WriteLine("set");
                using (sb.CurlyBracketsScope())
                {
                    sb.WriteLine($"if (!EqualityComparer<{typeFullName}>.Default.Equals({fieldName}, value))");
                    using (sb.CurlyBracketsScope())
                    {
                        if (typeSymbol.SpecialType == SpecialType.None)
                            sb.WriteLine($"UnwatchChild({fieldName});");
                        sb.WriteLine($"{fieldName} = value;");
                        if (typeSymbol.SpecialType == SpecialType.None)
                            sb.WriteLine($"WatchChild(value, \"{propertyName}\");");
                        sb.WriteLine($"OnPropertyChanged(value, \"{propertyName}\");");
                    }
                }
            }
            sb.WriteLine();
        }

        protected virtual void WriteCollectionProperty(ScriptBuilder sb, CodeGenerationContext ctx, string propertyName, string fieldName,
            ITypeSymbol typeSymbol, string collectionTypeString, bool saveSeparately)
        {
            AddAttributePreventSerialize(sb, false);
            sb.WriteLine($"private {collectionTypeString} {fieldName}Ob;");
            AddAttributePreventSerialize(sb, false);
            sb.WriteLine($"public {collectionTypeString} {propertyName}");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine($"get");
                using (sb.CurlyBracketsScope())
                {
                    sb.WriteLine($"if ({fieldName} == null) return null;");
                    sb.WriteLine($"TryInit{propertyName}();");
                    sb.WriteLine($"return {fieldName}Ob;");
                }
            }
            sb.WriteLine();
            sb.WriteLine($"public void Set{propertyName}({typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} val)");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine($"TryInit{propertyName}();");
                sb.WriteLine($"{fieldName}Ob.SwapSource(val);");
                sb.WriteLine($"{fieldName} = val;");
                sb.WriteLine($"OnPropertyChanged(val, \"{propertyName}\");");
            }
            sb.WriteLine($"private void TryInit{propertyName}()");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine($"if ({fieldName}Ob != null)");
                sb.WriteLine("    return;");
                sb.WriteLine($"{fieldName}Ob = new {collectionTypeString}(\"{propertyName}\",{fieldName}, {(saveSeparately ? "true" : "false")});");
                sb.WriteLine($"WatchChild({fieldName}Ob, \"{propertyName}\");");
                sb.WriteLine($"this.SetChild({fieldName}Ob);");
            }
            sb.WriteLine();
        }

        protected string GetCollectionTypeString(CollectionType colType, ISymbol[] typeSymbols)
        {
            var format = SymbolDisplayFormat.FullyQualifiedFormat;
            return colType switch
            {
                CollectionType.Array => $"ObservableArray<{typeSymbols[0].ToDisplayString(format)}>",
                CollectionType.List => $"ObservableList<{typeSymbols[0].ToDisplayString(format)}>",
                CollectionType.Dictionary => $"ObservableDictionary<{typeSymbols[0].ToDisplayString(format)}, {typeSymbols[1].ToDisplayString(format)}>",
                _ => throw new NotSupportedException()
            };
        }

        protected virtual void WriteImplementationsHead(ScriptBuilder sb, CodeGenerationContext ctx)
        {
            // ISavable Implementation
            sb.WriteLine($"public event PropertyChangeEventHandler<{_infoStore!.className}> PropertyChanged;");
            sb.WriteLine();
            AddAttributePreventSerialize(sb, true);
            sb.WriteLine("public ISavable Parent { get; private set; }");
            sb.WriteLine();
            AddAttributePreventSerialize(sb, false);
            sb.WriteLine("private string _svId;");
            sb.WriteLine("private bool _svIsDirty = true;");
            sb.WriteLine();
            AddAttributePreventSerialize(sb, true);
            sb.WriteLine("public bool IsDirty => _svIsDirty;");
            AddAttributePreventSerialize(sb, true);
            sb.WriteLine("public string SvId");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine("get => _svId;");
                sb.WriteLine("set");
                using (sb.CurlyBracketsScope())
                {
                    sb.WriteLine("OnSvIdChanging(ref value);");
                    sb.WriteLine("if (!EqualityComparer<string>.Default.Equals(_svId, value))");
                    using (sb.CurlyBracketsScope())
                    {
                        sb.WriteLine("var oldId = _svId;");
                        sb.WriteLine("_svId = value;");
                        sb.WriteLine("OnSvIdChanged();");
                        sb.WriteLine("this.TryUpdateId(oldId);");
                        sb.WriteLine("OnPropertyChanged(value, \"SvId\");");
                    }
                }
            }
            sb.WriteLine("partial void OnSvIdChanging(ref string svid);");
            sb.WriteLine("partial void OnSvIdChanged();");
            sb.WriteLine();
            // ISaveWithOrder Implementation
            if (_infoStore!.isOrderedClass)
            {
                AddAttributePreventSerialize(sb, false);
                sb.WriteLine("private int _svOrder;");
                sb.WriteLine();
                AddAttributePreventSerialize(sb, true);
                sb.WriteLine("public int SvOrder");
                using (sb.CurlyBracketsScope())
                {
                    sb.WriteLine("get => _svOrder;");
                    sb.WriteLine("set");
                    using (sb.CurlyBracketsScope())
                    {
                        sb.WriteLine("if (!EqualityComparer<int>.Default.Equals(_svOrder, value))");
                        using (sb.CurlyBracketsScope())
                        {
                            sb.WriteLine("_svOrder = value;");
                            sb.WriteLine("this.TryUpdateOrder(value);");
                            sb.WriteLine("OnPropertyChanged(value, \"SvOrder\");");
                        }
                    }
                }
                sb.WriteLine();
            }
        }

        protected virtual void WriteImplementationsFoot(ScriptBuilder sb, CodeGenerationContext ctx)
        {
            sb.WriteLine("void ISavable.SetParent(ISavable parent)");
            {
                using (sb.CurlyBracketsScope())
                {
                    sb.WriteLine("Parent = parent;");
                }
            }
            sb.WriteLine();

            sb.WriteLine("void ISavable.SetDirty(bool dirty, bool recursively)");
            {
                using (sb.CurlyBracketsScope())
                {
                    sb.WriteLine("_svIsDirty = dirty;");
                    if (_infoStore!.separatedProperties.Count > 0 || _infoStore!.separatedCollections.Count > 0)
                    {
                        sb.WriteLine("if (recursively)");
                        {
                            using (sb.CurlyBracketsScope())
                            {
                                foreach (var prop in _infoStore!.separatedProperties)
                                {
                                    var fieldName = GetOriginName(prop);
                                    sb.WriteLine($"if ({fieldName} is ISavable sv)");
                                    sb.WriteLine($"    sv.SetDirty(dirty, true);");
                                }
                                foreach (var kvp in _infoStore!.separatedCollections)
                                {
                                    sb.WriteLine($"({kvp.Key} as ISavable)?.SetDirty(dirty, true);");
                                }
                            }
                        }
                    }
                }
            }
            sb.WriteLine();

            sb.Write("private static readonly string[] _seperatedProperties = ");
            if (_infoStore!.separatedProperties.Count > 0)
            {
                sb.Write("new[] { ", true);
                foreach (var propName in _infoStore.separatedProperties)
                {
                    sb.Write("\"", true);
                    sb.Write(propName, true);
                    sb.Write("\", ", true);
                }
                sb.WriteLine("};", true);
            }
            else
                sb.WriteLine("null;", true);
            sb.Write("private static readonly string[] _separatedCollections = ");
            if (_infoStore!.separatedCollections.Count > 0)
            {
                sb.Write("new[] { ", true);
                foreach (var kvp in _infoStore.separatedCollections)
                {
                    sb.Write("\"", true);
                    sb.Write(kvp.Key, true);
                    sb.Write("\", ", true);
                }
                sb.WriteLine("};", true);
            }
            else
                sb.WriteLine("null;", true);
            sb.WriteLine("private void OnPropertyChanged<T>(T value, string propName)");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine("_svIsDirty = true;");
                sb.WriteLine("this.TrySave(propName, value, _seperatedProperties, _separatedCollections);");
                sb.WriteLine("PropertyChanged?.Invoke(this, propName);");
            }
            sb.WriteLine();

            sb.WriteLine("private void OnChildChanged<T>(T value, string propName)");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine("if (value is not ISavable sv || string.IsNullOrEmpty(sv.SvId))");
                sb.WriteLine("    return;");
                sb.WriteLine("this.TrySave(sv.SvId, sv, _seperatedProperties, _separatedCollections);");
                sb.WriteLine("PropertyChanged?.Invoke(this, sv.SvId);");
            }
            sb.WriteLine();

            sb.WriteLine("private void WatchChild<T>(T target, string propertyName)");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine("if (target is not ISavable<T> sv)");
                sb.WriteLine("    return;");
                sb.WriteLine("if (target is not ObservableCollection)");
                sb.WriteLine("    sv.SvId = propertyName;");
                sb.WriteLine("this.SetChild(sv);");
                sb.WriteLine("sv.PropertyChanged += OnChildChanged;");
            }
            sb.WriteLine();

            sb.WriteLine("private void UnwatchChild<T>(T target)");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine("if (target is not ISavable<T> sv)");
                sb.WriteLine("    return;");
                sb.WriteLine("sv.SetParent(null);");
                sb.WriteLine("sv.PropertyChanged -= OnChildChanged;");
            }
            sb.WriteLine();

            sb.WriteLine("public void Invalidate(bool recursively)");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine("(this as ISavable).SetDirty(true, recursively);");
                sb.WriteLine("var serializer = this.GetSerializer();");
                sb.WriteLine("if (serializer == null || string.IsNullOrEmpty(SvId))");
                sb.WriteLine("    return;");
                sb.WriteLine("if (this is ISerializeRoot sr)");
                sb.WriteLine("    serializer.FreshSaveByPolicy(this);");
                sb.WriteLine("else");
                sb.WriteLine("    PropertyChanged?.Invoke(this, SvId);");
            }

            sb.WriteLine("void ISavable.BeforeSerialize(Serializer serializer)");
            using (sb.CurlyBracketsScope())
            {
                sb.WriteLine("OnBeforeSerialize(serializer);");
            }
            sb.WriteLine("partial void OnBeforeSerialize(Serializer serializer);");
            sb.WriteLine();

            sb.WriteLine("void ISavable.AfterSerialize(Serializer serializer, PathBuilder path)");
            using (sb.CurlyBracketsScope())
            {
                if (_infoStore!.separatedProperties.Count > 0 || _infoStore!.separatedCollections.Count > 0)
                {
                    foreach (var prop in _infoStore!.separatedProperties)
                    {
                        var fieldName = GetOriginName(prop);
                        sb.WriteLine($"serializer.TrySaveObject({fieldName}, path, \"{prop}\");");
                    }
                    foreach (var kvp in _infoStore!.separatedCollections)
                    {
                        sb.WriteLine($"{kvp.Key}?.TrySave(serializer, path);");
                    }
                }
                sb.WriteLine("OnAfterSerialize(serializer, path);");
            }
            sb.WriteLine("partial void OnAfterSerialize(Serializer serializer, PathBuilder path);");
            sb.WriteLine();

            sb.WriteLine("void ISavable.AfterDeserialize(Serializer serializer, PathBuilder path)");
            using (sb.CurlyBracketsScope())
            {
                if (_infoStore!.separatedProperties.Count > 0 || _infoStore!.separatedCollections.Count > 0)
                {
                    foreach (var prop in _infoStore!.separatedProperties)
                    {
                        var fieldName = GetOriginName(prop);
                        sb.WriteLine($"{fieldName} = serializer.ReadObject<{_infoStore!.propTypeMappings[fieldName].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(path, \"{prop}\");");
                    }
                    foreach (var kvp in _infoStore!.separatedCollections)
                    {
                        var fieldName = GetOriginName(kvp.Key);
                        var (collectionType, typeParameters) = _infoStore!.collectionParameterMappings[fieldName];
                        var typeParametersStr = string.Join(", ", typeParameters.Select(symbol => symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                        sb.Write(fieldName);
                        sb.Write(" = serializer.", true);
                        sb.Write(collectionType switch
                        {
                            CollectionType.Array => $"ReadArray",
                            CollectionType.List => $"ReadList",
                            CollectionType.Dictionary => $"ReadDict",
                            _ => throw new NotSupportedException("CollectionType: " + collectionType.ToString()),
                        }, true);

                        var checkIsSavableSyntax = $"SvHelper.CheckIsSavable<{typeParameters.Last().ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>()";

                        sb.WriteLine($"<{typeParametersStr}>(path, \"{kvp.Key}\", {checkIsSavableSyntax});", true);
                        sb.WriteLine($"({kvp.Key} as ISavable).SetDirty(false, false);");
                    }
                }
                sb.WriteLine("OnAfterDeserialize(serializer, path);");
            }
            sb.WriteLine("partial void OnAfterDeserialize(Serializer serializer, PathBuilder path);");
            sb.WriteLine();
        }

        protected virtual void AddAttributePreventSerialize(ScriptBuilder sb, bool isOnProperty)
        {

        }

        private string GetOriginName(string generatedName)
        {
            foreach (var (fieldName, propName) in _infoStore!.nameMappings)
            {
                if (propName == generatedName)
                    return fieldName;
            }
            throw new ArgumentException(generatedName);
        }
    }
}
